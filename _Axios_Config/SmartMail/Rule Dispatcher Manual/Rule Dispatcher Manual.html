<!-- Set doctype for IE quirks mode. This ensures it displays well in IE. -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <link rel="stylesheet" type="text/css" href="doc_files/manualweb.css">
    <link rel="stylesheet" media="print" type="text/css" href="doc_files/manualprint.css">
    <title>Smartmail Rule Dispatcher</title>
</head>

<body>

<div id="content">

<div id="header">
<!--<img src="doc_files/header.jpg" alt="assyst logo">-->
</div>

<h1>Smartmail Rule Dispatcher</h1>

<div id="main">

<h2><a name="#introduction">Introduction</a></h2>
<p>
The rule dispatcher is intended to address some issues with the Smartmail configuration and execution:
    <ol>
    <li>The configurations are getting bigger and more complex. Unstructured scripting can become hard to follow.</li>
    <li>Bugs in one part of a script cause the entire script, and the jobs it's supposed to perform, to fail.</li>
    <li>It can be difficult to keep track of the context and purpose of the various templates, sql scripts and dofiles that are used in Smartmail configurations.</li> 
    <li>Hard to test and debug. The current approach to Smartmail testing is largely based on placing log statements in configs and then uncommenting and commenting those statements between testing and production.</li>
    </ol>
</p>

<p>
This is not a new product, nor does it extend existing Smartmail functionality. Rather, it's used to structure Smartmail configuration files to address the above concerns. <span class="emphasis">Note</span>, it only works with Smartmail 1.4 and upwards. Earlier versions of the Smartmail are not compatible with the dispatcher.
</p>

<h2>Including the dispatcher in a Smartmail configuration</h2>

<h3>Smartmail QuickConfig</h3>
<p>
The dispatcher is basically another dofile. To use it in a configuration, invoke the dofile <i>after</i> that of the <span class="code">SmartmailParms.lua</span> file. Place these 2 <span class="code">dofile</span> calls at the top of the configuration file.
<pre>
dofile("dofiles\\SmartMailParms.lua")
dofile("dofiles\\SmartMailRuleDispatcher.lua")
</pre>
These are only <span class="code">dofile</span> calls that should be necessary and allow the rest of the configuration to be written in the dispatcher style. 
</p>

<h3>Plain Smartmail</h3>
<p>
In this case, the dispatcher may be the only dofile. Place the invocation of the dofile at the top of the configuration file. After that, you will need to set up the Smartmail <span class="code">assystdb</span> and <span class="code">smtp</span> sections. See the main Smartmail manual for more details on how to do this.
</p>

<h2><a name="#configuring">Configuring Smartmail using the dispatcher</a></h3>

<h3><a name="#controls">The controls section</a></h3>
<p>
Having included the dispatcher in the configuration, it adds three new configuration sections. The first of these is the <span class="code">controls</span> section. 
This section contains the parameters that control the behaviour of the dispatcher.
<ul>
<li><span class="code">test_mode_on</span>: When set to <span class="code">true</span>, the dispatcher executes a set of test activities. These are defined as part of the rules in the <a href="#set_of_rules">set_of_rules</a> section. The idea is to equip Smartmail with means to test and debug business logic without having to write a separate configuration. The test activities can involve writing to a log file or emailing the Smartmail administrator or tester - instead of logging actions in assyst or emailing an affected user or SVD. By default, <span class="code">test_mode_on</span> is set to <span class="code">false</span>.</li>
<li><span class="code">debug_to_outlook</span>: This is the existing Smartmail parameter. To improve clarity it has been co-opted into the <span class="code">controls</span> section. When set to <span class="code">true</span>, emails that are generated by Smartmail are not sent. Instead, the message is generated and displayed in an outlook window allowing to you examine the message content and recipients. By default, this control is set to <span class="code">false</span>, i.e. emails generated by Smartmail are sent to the specified recipients.</li>
<li><span class="code">email_test_filter</span>: The final test-focussed control. This allows you to generate and send emails while enabling a filter to only send emails to those people involved in testing. 
<pre>
	email_test_filter = {
		ON = true,
		allowed = {
			"tester1@mysvd.com", "tester2@mysvd.com", "bigcheese@mysvd.com",
		}, 
		otherwise = "noread@mysvd.com"
	}
</pre>
The <span class="code">ON</span> parameter is a boolean: <span class="code">true</span> activates the filter while <span class="code">false</span> deactivates it. When activated, the address list of <span class="emphasis">every</span> generated email is examined before being sent. The email addresses in the <span class="code">allowed</span> list are retained. Every other email address is replaced with the address specified in the <span class="code">otherwise</span> parameter. <span class="emphasis">Note</span>, in the <span class="code">otherwise</span> case only the email address component of the recipient is changed; the name of the recipient is retained.</li>
<li><span class="code">admin_email</span>: The dispatcher is designed to keep going even when one of the rules fails. These failures are entered into the Smartmail log file as <span class="code">ERROR</span> entries. 
In addition to this, the dispatcher can be configured via the <span class="code">admin_email</span> control to send an email to an administrator to alert them of rules failures.
<div class="page-break"></div>
<pre>
	admin_email = {
		ON		= true, 
		name		= "Smartmail admin", 
		email		= "smadmin@myorg.com",
		template	= strPathToTemplates .. "\\rule_dispatcher_error.txt"
	}
</pre>
The <span class="code">ON</span> parameter is a boolean: <span class="code">true</span> activates the sending of alert emails to the person specified in the <span class="code">name</span> and <span class="code">email</span> parameters; <span class="code">false</span> deactivates the email alerts. The <span class="code">template</span> is a Smartmail email template file. The dispatcher error details are available to that template in the <span class="code">$RD_ERROR_MESSAGE</span> template variable.</li>
<li><span class="code">use_import_processor</span>: This setting governs action logging from Smartmail using the Windows&trade; utilities. When set to <span class="code">true</span> it <em>enforces</em> the logging of all actions using the <span class="code">import processor</span>. In this mode, Smartmail only writes the import processor file. Separately of this, the <span class="code">assyst import processor</span> needs to be configured to pick up those files and log the actions in assyst. Where assyst sites generate a large number of Smartmail jobs, this is a way to speed up the Smartmail execution and throughput of jobs. The tradeoff is that action logging defined in a Smartmail script will not occur as the Smartmail script is run - it will lag behind. The default setting is <span class="code">false</span>. When set to this value, the method of logging the action from a Smartmail script is defined on an action-by-action basis.</li>
</ul>
</p>


<h3><a name="environment">The environment section</a></h3>
<p>
This section is used to define a set a variables that are available for use throughout the Smartmail configuration. The variables are specified in a key = value format. For example, <span class="code">admin_email = "admin@mycompany.com"</span>. When the dispatcher runs through the <span class="code">environment</span> section, it will load these variables into the global environment, i.e. make them global variables that can be seen and used throughout the configuration file. However, before doing so, it checks that the corresponding global variable is not already used. If it is, the configuration fails. This is done to prevent overwriting of parameters and values that have already been set in Smartmail. 
</p>

<pre>
environment {
    LOCATION_LIST	= {"BUILDING1-", "BUILDING2-"},
}
</pre>

<h3><a name="set_of_rules">The set_of_rules section - Organising the Smartmail tasks</a></h3>
<p>
This section organises the Smartmail configuration script into a set of rules. 
</p>
<pre>
set_of_rules {
    { rule 1 },
    { rule 2 },
    .
    .
    .
    { rule n },
}
</pre> 

<p>
Each rule <span class="emphasis">must</span> contain the following elements:
<ul>
    <li><span class="code">name</span>: The name of the rule. Where possible, this should match up to a customer's stated business requirement.</li>
    <li>
        <span class="code">condition</span>: This must evaluate to <span class="code">true</span> for the rule to run. 
        <span class="emphasis">Note</span>, the rule dispatcher checks the type of the value returned by the condition. 
        If that value is not <span class="code">true</span> or <span class="code">false</span> then the dispatcher writes 
        an error message to the Smartmail log file and will not execute that rule.
    </li>
    <li><span class="code">activities</span>: If the above condition is met, this is the set of activities or tasks that will be run.</li>
    <li><span class="code">"continue"|"stop" flag</span>: One of these values must be the last entry in each rule. If set to <span class="code">"continue"</span>, the dispatcher will continue on to the next rule. If set to <span class="code">stop</span>, the dispatcher skips the rest of the configuration file and finishes.
</ul>
</p>

<p>
Each rule may contain the following elements:
<ul>
<li>
<span class="code">parameters</span>: A list of key-value parameters that are available to the rule condition and activities. <span class="emphasis">Note</span>, these parameters are only available within the current rule.</span> As such, they differ from the variables in the <span class="code">environment</span> section. One of the goals of the dispatcher-style configuration is to keep the information that's relevant to a rule within the rule. Therefore, you should favour putting variables into the rule parameters. Only define variables in the environment section when they are used across a number of rules in the configuration. 
</li> 
<li>
<span class="code">data_generation</span>: This is a list of lua files containing SQL queries. The purpose of each file is to retrieve extra data that will be used in the <span class="code">condition</span> or in the <span class="code">activities</span>. This is similar to the <span class="code">xsql</span> specification currently available to Smartmail - with the ability to specify a set of files instead of a single file. With the aim of giving the rules more context, the same SQL file can be specified in the <span class="code">data_generation</span> section of different rules. The dispatcher keeps track of the SQL files that it has already executed and retains their results. You get to state and to see the dependencies of each rule without incurring a performance hit. 
</li>
<li>
<span class="code">activities_test</span>: If the <span class="code">test_mode_on</span> flag in the environment section is set to <span class="code">true</span>, then the dispatcher goes looking for this element in each of the rules. <span class="emphasis">Note</span>, if <span class="code">test_mode_on</span> is <span class="code">true</span> and this element is missing from a rule, then the dispatcher logs an error and skips the rule.
</li>
</ul>

<div class="page-break"></div>
<h2><a name="#example">Walking through an example dispatcher-style Smartmail configuration</a></h2>

<pre>
dofile("dofiles\\SmartMailParms.lua")
dofile("dofiles\\SmartMailRuleDispatcher.lua")

controls {
    test_mode_on = false,
    debug_to_outlook = true,
    use_import_processor = true
}

environment {
    CONF_IMPORT_PROFILE = [[ "GENERAL_FAULT" ]],
}

set_of_rules {
   {
        name = [[ "Send email to assigned SVD" ]],
        parameters = [[
            excluded_svds = { "ROBOTS", "HOLDING"}
        ]],
        data_generation =  [[  {strPathToSql .. "\\parent_sql.lua"}  ]], 
        condition = [[ 
            EVENT_TYPE == "i" and 
            (not element(ASSIGNED_SVD, excluded_svds)) 
        ]],
        activities = {
            {"email",
                recipients_special	= [[ coalesce{logging_user(), affected_user()} ]],
                subject 		= [[ coalesce_recall{ "hi to logging user", "hi to affected user"} ]],
                body 			= [[ strPathToTemplates .. "\\assign_open.html" ]]
            },
            { "script",
                [[
                    LOGGER:info("I can put any lua code here")
                ]]
            }
        },
        activities_test = {
            { "log",
                [[ "EVENT_TYPE = " .. EVENT_TYPE ]], 
                [[ ((affected_user() and  "Affected user has email address") ]] ,
                [[ (logging_user() and "Logging user has email address") ]],
            }
        },
        "continue",
    },
    
    {
        name = [[ "Assign Task to Manager for Authorization for IM Process" ]],
        data_generation = [[ { strPathToSQL .. "\\usr_details_sql.lua"} ]],
        condition = [[
            tonumber(ACT_TYPE_COUNT) == 1)) 
            and (EVENT_TYPE == "d")
            and (
                ((ASS_USR_SC or "") == "ZZ_AUTH_VP") 
                or ((ASS_USR_SC or "") == "ZZ_AUTH_MANAGER")
            )
        ]],
        activities = {
            -- First activity figures out the contact user's manager (for use in subsequent activities)
            -- Based on manager result, this turns on conditional activities.
            { "script",
                [[
                    if ((ASS_USR_SC or "") == "ZZ_AUTH_VP") then
                        MGR_ASSIGNEE = USR_VP_ALIAS
                        MGR_ASSIGNEE_SC = USR_VP_SC
                    else
                        MGR_ASSIGNEE = USR_MGR_ALIAS
                        MGR_ASSIGNEE_SC = USR_MGR_SC
                    end
                ]]
            },
            { "conditional_group", [[ MGR_ASSIGNEE ]], {"assign"} },
            { "conditional_group", [[ not MGR_ASSIGNEE]], {"send_error_email"} },
            
            conditional.assign { "action",
                filename 	= [[ strAIMimportpath .. "AutoAssign" .. ACT_REG_ID .. ".imp" ]],
                INCIDENTREF 	= [[ EVENT_TYPE_AIM .. EVENT_REF ]],
                ACTIONTYPE 	= [[ "ASSIGN" ]],
                ASSIGNEDTO 	= [[ MGR_ASSIGNEE ]],
                ACTIONEDBY 	= [[ ACTIONING_USR_SC ]],
                EVENTIMPPROFILE	= [[ "ASSIGNVP" ]],
                DESCRIPTION 	= [[ "Auto assigned authorization." ]],                
            },
            conditional.send_error_email { "email", 
                recipients_special	= [[ { "Smartmail Administrator", strAdminEmail} ]],
                subject 		= [[ "Request $EVENT_REF has been opened" ]],
                body 			= [[ strPathToTemplates .. "\\assign_Open.html" ]],
            }
        },
        test_activities = {
            {"log", 
                [[ "TEST: Assign Task to Manager for Authorization for IM Process || TRIGGER TESTED" ]],
            }
        },
        "continue",
    },    

    {
        name = [[ "Re-assignment of decision task to contact user's manager " ]],
        data_generation = [[ { strPathToSql.."\\parent_sql.lua" } ]] ,
        condition = [[ 
                (EVENT_TYPE == "d")
                and (not isnull(MGR_ASSIGNEE))
        ]],
        activities = {
            { "new_action",
                acli 		= [[ straclipath ]],
                filename 	= [[ strAIMimportpath .. "AutoReAssign" .. ACT_REG_ID .. ".imp" ]],
                INCIDENTREF 	= [[ EVENT_TYPE_U .. EVENT_REF ]],
                ACTIONTYPE 	= [[ "ASSIGN" ]],
                ASSIGNEDTO 	= [[ MGR_ASSIGNEE ]],
                ACTIONEDBY 	= [[ ACTIONING_USR_SC ]],
                EVENTIMPPROFILE	= [[ "ASSIGNVP" ]],
                ACTIONIMPPROFILE = [[ "GENERAL ACTION" ]],
                DESCRIPTION	= [[ "Auto assigned authorization" ]],
            },
        },
        "stop",
    },
}
</pre>

<h3>Formatting the rules</h3>

<h4>Indentation</h4>
<p>
It's not compulsory and the dispatcher will process the rule set without indentation. However, visually, it makes the configuration a lot easier to follow. I would strongly recommend that you maintain it.
</p>

<h4>Writing rule inputs: left and right-hand side</h4>
<p>
Every input is written as follows: 
<pre>input = [[ lua expression ]]</pre>
The effect of enclosing the right-hand side in square brackets is to defer evaluation of the expression until the rule is being executed. Without these brackets, Smartmail will evaluate the expression straight after loading the configuration. This leads to confusing behaviour and errors.
</p>
<p>
The dispatcher enforces the presence of the <span class="code">[[ ]]</span> in a validation step. If this notation is missing, the dispatcher writes an error to the Smartmail log file and will not execute the rule.
</p>

<div class="page-break"></div>
<h3>Activities</h3>
<p>
The example configuration above shows the set of activities that are made available by the dispatcher: 
<ul>
<li><span class="code">script</span></li>
<li><span class="code">email</span></li>
<li><span class="code">log</span></li> 
<li><span class="code">new_action</span></li>
<li><span class="code">update_event</span></li>
<li><span class="code">new_action_ejb</span></li>
<li><span class="code">update_event_ejb</span></li>
<li><span class="code">conditional_group</span></li>
</ul>
Each of these is invoked by naming the activity, then supplying its parameter list. 
</p>
<p>
Activities do not return new values to the dispatcher. The dispatcher's only responsibility is to start the activity and check that it ran without an error. If an error occurs, the dispatcher writes a message to the Smartmail log file and then continues on to the next activity. 
</p>

<h4>The script activity</h4>
<p>
This is the most generic of the activities. Any lua code can be run inside the [[]] parameter.

<pre>
{ "script",
    [[
        LOGGER:info("I can write log messages")
        
        -- I can email people
        email{
            sender = "bob@mycompany.com",
            recipients = {"bart@mycompany.com", "marge@mycompany.com"},
            header = {
                from = "Bob Boss",
                to = '"Bart &lt;bart@mycompany.com&gt;, Marge &lt;marge@mycompany.com&gt;"',
                subject = "Hello",
            },
            body = "hello.html",
        }
        
        -- I could output things to a file
        fhandle = io.open("output_file.txt")
        f:write("hello from Smartmail")
        fhandle:close()
    ]]
}
</pre>
<p>
Given its flexibility, you could write all the rule business logic here. However, you would lose the structure and use of the helper functions that the dispatcher provides for the different activities. 
<p>
The are two cases where the use of the <span class="code">script</span> activity is advised:
<ol>
<li>To carry out activities that are not currently supported by the dispatcher, e.g. reading or writing data from or to a file.</li>
<li>To derive data from Smartmail query results for use in subsequent activities. In the example configuration above, the rule titled <span class="code">"Assign Task to Manager for Authorization for IM Process"</span> has a <span class="code">script</span> section (reproduced below) that works out the contact user's manager. The result is stored in the <span class="code">MGR_ASSIGNEE</span> variable, which is in turn used in a later email activity.</li>
</ol>
<pre>
{ "script",
    [[
        if ((ASS_USR_SC or "") == "ZZ_AUTH_VP") then
            MGR_ASSIGNEE = USR_VP_ALIAS
            MGR_ASSIGNEE_SC = USR_VP_SC
        else
            MGR_ASSIGNEE = USR_MGR_ALIAS
            MGR_ASSIGNEE_SC = USR_MGR_SC
        end
    ]]
},
</pre>

<div class="page-break"></div>
<h4>The email activity</h4>
<p>
The <span class="code">email</span> activity is a wrapper about the existing Smartmail email function (see the main Smartmail manual). It layers some shortcuts on top of the standard functionality to make the composing and sending of emails more convenient. In particular, it focusses on flexible specification and assembly of email recipients.
</p>
<p>
The entire vanilla Smartmail email function is available here. So, for example, you could write:
<pre>
{ "email",
    sender = [["bob@mycompany.com"]],
    recipients = [[ {"bart@mycompany.com", "marge@mycompany.com"}]],
    header = {
        from = [[ "Bob Boss" ]],
        to = [['"Bart &lt;bart@mycompany.com&gt;, Marge &lt;marge@mycompany.com&gt;"']],
        subject = [[ "Hello" ]],
    },
    body = [[ "hello.html" ]],
}
</pre>

The following email calls shows the range of shortcuts available to the dispatcher:
<pre>
{ "email",
    recipients_special = [[ 
        {
           {"Bart", "bart@mycompany.com"},
           {"Marge", "marge@mycompany.com"},
        }
    ]],
    subject = [[ "Hello" } ]],
    body = [[ "hello.html" ]],
}
</pre>

<p>
If not specified, then the sender defaults to the value specified in the Smartmail QuickConfig. The header section is removed and <span class="code">subject</span> is moved into the main parameter list.
</p>

<p>
The <span class="code">recipients_special</span> parameter allows email recipients to be specified as a list of name-email pairs. The dispatcher then takes care of formatting that data into SMTP-compliant recipient data. In addition, the dispatcher provides you with a set of <strong>out-of-the-box</strong> email targets. These targets are function calls that, when invoked, return a list of name-email pairs. The available targets are:
<ul>
<li>affected_user()</li>
<li>reporting_user()</li>
<li>logging_user()</li>
<li>assigned_user()</li>
<li>actioning_user()</li>
<li>actioning_supplier()</li>
<li>additional_affected_users()</li>
</ul>
You have the ability to define <strong>custom email targets</strong> using SQL queries. Inside the <span class="code">recipients_special</span> parameter you invoke the <span class="code">custom_target</span> function, supplying the path to the SQL query that retrieves the recipient data. The SQL result set is expected to contain 2 columns labelled <span class="code">TARGET_NAME</span> and <span class="code">TARGET_EMAIL</span>. The dispatcher checks for the presence of these columns and logs an error if either is missing.

<p>
Your hard-coded email recipients, the out-of-the-box targets and custom targets can be used separately and together in the <span class="code">recipients_special</span> parameter. <strong>Examples</strong> of how this can be done are shown below: 
<pre>
-- A single hard-coded recipient
recipients_special = [[ {"Joe Bloggs", "joeyb@bloggs.com"} ]]
</pre>
<pre>
-- Multiple hard-coded recipients. Note, this the enclosing {} about the set of name-email pairs.
recipients_special = [[ 
	{ 
		{"Joe Bloggs", "joeyb@bloggs.com"}, 
		{"Bill Bloggs", "billyb@bloggs.com"} 
	} 
]]
</pre>
<pre>
-- Combining an out-of-the-box target with a hard-coded recipient.
-- Emails would go to the union of the two. 
recipients_special = [[
	{
		assigned_user(), 
		{"Joe Bloggs", "joeyb@bloggs.com"}, 
	}
]]
</pre>
<pre>
-- Falling back from affected user to reporting user to logging user to hard-coded user. 
-- Combining that result with a custom target for item users. 
recipients_special = [[
	{
		affected_user() or reporting_user() or logging_user() or {"Joe Bloggs", "joeyb@bloggs.com"}, 
		custom_target(pathToSql .. "\\item_users.sql")
	}
]]
</pre>

<span class="emphasis">Finally</span>, the email activity supplies you with a <strong>shortcut</strong> for the following <strong>pattern</strong> (written in pseudo-code):
<pre>
if assigned user has email address then
    email the assigned user with subject "hi to assigned user" using the template "assign_ass_usr.html"
elseif assigned svd has email address then
    email the assigned svd with subject "hi to assigned svd" using the template "assign_ass_svd.html"
elseif logging user has email address then
    email the logging user with subject "hi to logging user" using the template "assign_log_usr.html"
end
</pre>
This is achieved as follows:
<pre>
{ "email",
    recipients_special = [[ coalesce{ assigned_user(), assigned_svd(), logging_user()} ]],
    subject = [[ coalesce_recall{ "hi to ASS_USR_N", "hi to ASS_SVD_N", "hi to LOG_USR_N" } ]],
    body = [[ coalesce_recall{ "assign_ass_usr.html", "assign_ass_svd.html", "assign_log_usr.html"} ]]
}
</pre>
<ul>
<li><span class="code">coalesce</span> picks the first non-nil entry from the supplied list of values.</li> 
<li><span class="code">coalesce_recall</span> retrieves the index of the result of <span class="code">coalesce</span> and uses that to get the corresponding value from its supplied list of values.</li>
<li><span class="emphasis">Note</span>, <span class="code">coalesce</span> is restricted to one call per activity.</li>
<li><span class="emphasis">Note</span>, the targets listed in the pattern are there as an illustration. You can use any target (hard-coded, out-of-box or custom) you wish as input to the <span class="code">coalesce</span> function.
</ul>
</p>


<h4>The log activity</h4>
This is just a simple convenience function. It takes a list of statements that you want written to the log file and outputs them, one per line, to the Smartmail log file as <span class="code">INFO</span> messages.

<pre>
{ "log",
    [[ "EVENT_TYPE = " .. EVENT_TYPE ]], 
    [[ (affected_user() or  "Affected user is missing email address") ]] ,
    [[ (logging_user() and "Logging user has email address") or ("Logging user is missing email address") ]],
}
</pre>

<div class="page-break"></div>
<h4>new_action</h4>

In Smartmail configuration, a lot of the action logging scripting is buried in the dofiles. It looks something like this:
<pre>
ImpFileName = strAIMimportpath .. "AutoAssign" .. ACT_REG_ID .. ".imp"
ImpCmd = "@*@INCIDENTREF@*@:" .. EVENT_TYPE_AIM .. EVENT_REF
ImpCmd = ImpCmd .. "\n" .. "@*@ACTIONTYPE@*@:ASSIGN"
ImpCmd = ImpCmd .. "\n" .. "@*@ASSIGNEDTO@*@:"  .. MGR_ASSIGNEE
ImpCmd = ImpCmd .. "\n" .. "@*@ACTIONEDBY@*@:"  .. ACTIONING_USR_SC
ImpCmd = ImpCmd .. "\n" .. "@*@EVENTIMPPROFILE@*@:ASSIGNVP"
ImpCmd = ImpCmd .. "\nAuto assigned authorization"
ImpCmd = ImpCmd .. "\n|END OF ACTION|"
ImpCmd = ImpCmd .. "\n"

SMEXT_createIMPfile(ImpFileName,ImpCmd)
</pre>

The <span class="code">new_action</span> helper function cleans up the action logging by providing a <span class="code">parameter = [[ value ]]</span> interface.
It takes care of writing out the import file. The option also exists to use the <span class="code">acli</span> to log the action. 
If the <span class="code">use_import_processor</span> environment parameter is set to <span class="code">false</span> and the <span class="code">acli</span>
parameter is provided (as below, using the QuickConfig value) then the <span class="code">acli</span> will be invoked to log the action. 

<pre>
{ "new_action",
    acli 		= [[ straclipath ]],
    filename 		= [[ strAIMimportpath .. "AutoAssign" .. ACT_REG_ID .. ".imp" ]],
    INCIDENTREF 	= [[ EVENT_TYPE_AIM .. EVENT_REF ]],
    ACTIONTYPE 		= [[ "ASSIGN" ]],
    ASSIGNEDTO 		= [[ MGR_ASSIGNEE ]],
    ACTIONEDBY 		= [[ ACTIONING_USR_SC ]],
    EVENTIMPPROFILE 	= [[ "GENERAL FAULT" ]],
    ACTIONIMPPROFILE 	= [[ "ASSIGNVP" ]],
    DESCRIPTION 	= [[ "Auto assigned authorization" ]],
}
</pre>

<h4>update_event</h4>
With regard to updating events, this helper function has the same purpose and behaves in the same manner as the <span class="code">new_action</span> function.

<h4>new_action_ejb</h4>
This activity logs a new action via the assystweb EJB interface. There are 2 dependencies here:
<ol>
<li>assystweb is installed and running on the customer site.</li>
<li>The integrations RESTful API (integrations' method of moving data in and out of assystweb) must also be installed and running at the customer site.</li> 
</ol>
When logging an action, you supply the EJB parameters. acli parameters are not understood by assystweb.
For example:
<pre>
{ "new_action_ejb",
	eventId		= [[ EVENT_ID ]],
	remarks	 	= [[ "The error was caused be a typo in the configuration file."]],
	actionTypeId 	= [[ lookup{"ActionType", "INVESTIGATION"} ]],
}
</pre>
<p>
Instead of <span class="code">DESCRIPTION</span>, you supply <span class="code">remarks</span>. Instead of <span class="code">INCIDENT_REF</span>, you supply <span class="code">eventId</span>.
You can consult the Javadocs for the assystweb EJB interface to find out the parameter names used. 
</p>

<p>
The new_action_ejb activity also supplies you a way to instruct the dispatcher to perform a lookup before logging the action. In the above example, the <span class="code">actionTypeId</span> is looked up by calling the function <span class="code">lookup</span> with the EJB object-shortcode pair, <span class="code">{"ActionType", "INVESTIGATION"}</span>. This tells the dispatcher to find the id of the <span class="code">ActionType</span> whose shortcode is <span class="code">INVESTIGATION</span>. This notation can be used for any of the EJB objects. 
</p>

<h4>update_event_ejb</h4>
This use the same interfaces as the <span class="code">new_action_ejb</span> activity to update an existing event. 
<pre>
{ "update_event_ejb",  
	eventId 	= [[ EVENT_ID ]],
	priorityId 	= [[ lookup{"Priority", "PRIORITY 3"} ]],
},
</pre>

<div class="page-break"></div>
<h4>conditional_group</h4>
The <span class="code">conditional_group</span> activity turns on a set of activities, identified by labels, based on the outcome of a test.
<pre>
{ "script",
   [[
      LOGGER:info("I can put any lua code in a script activity."), 
      LOGGER:info("But I recommend using it to derive data for use in subsequent activities.")
      LOG_HELLO = false
      LOG_GOODBYE = true
   ]]
},

{ "conditional_group", [[ LOG_HELLO ]], { "log_hello"} },
{ "conditional_group", [[ LOG_GOODBYE ]], { "log_goodbye","log_goodluck" } },

conditional.log_hello { "log", 
	[[ "Hi, I'm LOG HELLO" ]],
},
{ "log", 
	[[ "Hi, I run regardless â€“ if log hello is turned on, I run after it."]],
	[[ "If log goodbye is turned on, I run before it". ]],
},
conditional.log_goodbye { "log", 
	[[ "Bye, I'm LOG GOODBYE" ]],
},
conditional.log_goodluck{ "log",
	[[ "And goodluck, I'm LOG GOODLUCK" ]],
},
--conditional.log_hello { "log", 
--    [[ "This is a repeat of a condition label. This generates an error. " ]]
--}, 
</pre>
<p>
In the above example, the <span class="code">script</span> activity is used to set the values of 2 flags. The <span class="code">conditional_group</span> activities that follow the <span class="code">script</span> activity test the values of the flags in the portion between <span class="code">[[ ]]</span>. If the test returns <span class="code">true</span>, then the <strong>list</strong> of labels defined after the test are activated. Each label identifies an activity. Those activities, if turned on, are <strong>executed in the order in which they appear in the dispatcher configuration</strong>.
</p>

<div class="page-break"></div>
<h2>Logging and Testing</h2>

<h3>General Logging</h3>
The dispatcher adds new <span class="code">INFO</span> and <span class="code">ERROR</span> messages to the Smartmail log file. 
The <span class="code">INFO</span> messages contain the action type that the configuration file is written for, the ID of the specific action that triggered Smartmail and the name of the rule that is currently being evaluated. 
For example:
<pre>
22/11/2011 12:43:49 INFO ===== Rule >> ASSIGN >> 'Email affected user' for ACT_REG_ID 204 ====
22/11/2011 12:43:49 INFO         Rule >> ASSIGN >> 'Email affected user' for ACT_REG_ID 204. 
Running data generation file '\SQL\\parent_sql.lua'.
22/11/2011 12:43:49 INFO         Got 1 row.
22/11/2011 12:43:49 INFO         Got 1 row.
22/11/2011 12:43:49 INFO         Got 1 row.
22/11/2011 12:43:49 INFO         Got 1 row.
22/11/2011 12:43:49 INFO         Rule >> ASSIGN >> 'Email affected user' for ACT_REG_ID 204 has been triggered. 
Proceeding with activities.
22/11/2011 12:43:49 INFO I can put any lua code here
22/11/2011 12:43:49 INFO ===== Rule >> ASSIGN >> 'Assign of task to user's manager' for ACT_REG_ID 204 =====
22/11/2011 12:43:49 INFO         Rule >> ASSIGN >> 'Assign of task to user's manager' for ACT_REG_ID 204. 
Data generation file 'SQL\\parent_sql.lua' has already been run. Using cached variable values.
22/11/2011 12:43:49 INFO         Rule >> ASSIGN >> 'Assign of task to user's manager' for ACT_REG_ID 204. 
Running data generation file '..\dofiles\MGRreassign.lua'.
22/11/2011 12:43:49 INFO         Rule >> ASSIGN >> 'Assign of task to user's manager' for ACT_REG_ID 204 
has been triggered. 
Proceeding with activities.
22/11/2011 12:43:49 INFO Owner of the database christopher.mcguire@axiossystems.com
22/11/2011 12:43:49 INFO Sending email ...
22/11/2011 12:43:50 INFO  ... sent.
22/11/2011 12:43:50 INFO         Rule >> ASSIGN >> 'Assign of task to user's manager' for ACT_REG_ID 204 has been 
triggered and ends with a stop flag. 
The remaining rules will not be executed.
</pre>

<p>
Errors are also placed in the context of the action type, action id and rule. If I incorrectly write the rule name (forgetting to include one of the ").
<pre>
name = [[ Email affected user" ]] 
</pre>
Then the following error is written to the log file.
<pre>
22/11/2011 12:58:04 INFO === Rule >> ASSIGN >> Rule number 1 for ACT_REG_ID 204 ====
22/11/2011 12:58:04 ERROR Rule >> ASSIGN >> Number 1 for ACT_REG_ID 204. 
Name failed validation. Is the rule name present and correctly formatted?
</pre>
If an error occurs further on in a rule. For example, I put the following into a script section.
<pre>
{ "script",
    [[
        This is a deliberate error
    ]]
}
</pre>
This in invalid piece of Lua scripting, i.e. take away the [[]] and it's a collection of words that have no meaning to Lua. 
It results in the following error in the log file:
<pre>
22/11/2011 13:02:06 ERROR Rule >> ASSIGN >> 'Email affected user' for ACT_REG_ID 204 >> 
    Activity 2 failed with message:  Failure evaluating script section. [string " 
</pre>
<p>
<span class="emphasis">Note</span>, as mentioned earlier, the dispatcher will continue on to the other rules after logging the error. 
</p>

<div class="page-break"></div>
<h3>Logging in Test Mode</h3>
<p>
The above logging also occurs when the environment parameter <span class="code">test_mode_on</span> is set to <span class="code">true</span>. 
In addition to this, the following message is written out for each rule:
</p>
<pre>
22/11/2011 14:37:54 INFO Rule >> ASSIGN >> 'Email affected user' for ACT_REG_ID 204 . Test mode is ON.
</pre>
<p>
The activities are referred to as <span class="code">test_activities</span>.
</p>
<pre>
22/11/2011 14:37:54 INFO Rule >> ASSIGN >> 'Email affected user' for ACT_REG_ID 204 has been triggered. 
Proceeding with test activities.
</pre>

<h3>Disabling an activity</h3>
Any activity can be disabled by placing the keyword <span class="code">disable</span> before the rule. For example, 
<pre>
disable {"email",
    recipients_special = [[ coalesce{affected_user(), logging_user()} ]],
    subject = [[ coalesce_recall{ "hi to affected user", "hi to logging user()" } ]],
    body =  [[ strPathToTemplates .. "\\assign_open.html" ]]
},
</pre>
This is also recorded in the log file:
<pre>
22/11/2011 14:45:20 INFO Rule >> ASSIGN >> 'Email affected user' for ACT_REG_ID 204 >> 
        Activity 1 has been marked as disabled. Skipping...
</pre>

<h2>Conclusions and Moving Forward</h2>
This dispatcher, I believe, goes a good way to addressing the issues outlined at the start of this document:
<ul>
<li>The configurations and the business logic are more structured.</li>
<li>The configuration is less sensitive to coding errors.</li>
<li>SQL scripts are attached to specific rules, giving them more context.</li>
<li>Testing and logging have been improved - hopefully making development and testing of scripts easier.</li>
</ul>

<p>
There is also the potential for a division of labour between dispatcher and scripters (AGS, Service Desk, Customer, Integrations). The helper functions are reusable wrappers around the basic functionality provided by aLua. More such wrappers could be added to simplify the configurations. Some people could concentrate on writing and maintaining the configurations and others do the same with the helper functions. 
</p>


</div> <!-- main -->
</div> <!-- content -->
</body>
</html>